#   pactivate v0.4.0            https://github.com/0cjs/pactivate

[ -n "$BASH_VERSION" ] || { echo 1>&2 "source (.) this with Bash."; exit 9; }
#   https://stackoverflow.com/a/28776166/107294
(return 0 2>/dev/null) \
    || { echo 1>&2 "source (.) pactivate with Bash."; exit 9; }

__pa_cleanup() {
    unset __pa_cleanup __pa_echo \
        __pa_builddir __pa_quiet __pa_python __pa_python_deref __pa_pyver \
        __pa_bootdir __pa_basedir __pa_requirements
}
__pa_echo() { [[ -n $__pa_quiet ]] || echo "$@"; }

__pa_basedir=$(cd "$(dirname "$BASH_SOURCE")" && pwd -P)
__pa_builddir=
__pa_quiet=
while [[ $# -gt 0 ]]; do case "$1" in
    -b) shift; __pa_builddir="$1"; shift;;
    -B) shift; __pa_basedir="$1"; shift;;
    -q) shift; __pa_quiet=-q;;
    *)  echo 1>&2 "pactivate: unknown argument: $1"; __pa_cleanup; return 2;;
esac; done;

#   Find the path to the Python interpreter to use.
if [[ -e $__pa_basedir/.python || -L $__pa_basedir/.python ]]; then
    #   -e returns false if .python is a dangling link. Even so, if the link
    #   exists (-L returns true) we use it anyway so that the user can see
    #   the error.
    __pa_python=$__pa_basedir/.python
elif [[ "${MSYSTEM:-}" =~ (MSYS|MINGW).* ]] && type -p py >/dev/null; then
    #   We're on Windows with MINGW; find out its default interpreter.
    __pa_python=$(py -c 'import sys; print(sys.executable)')
elif type -p python3 >/dev/null; then
    __pa_python=$(type -p python3)
elif type -p python >/dev/null; then
    __pa_python=$(type -p python)
else
    echo 1>&2 "Cannot find Python interpreter. Link .python to one."
    return 3
fi
echo "Using: $__pa_python"
#   Confirm the executable responds to the `--version` option.
if ! "$__pa_python" --version >/dev/null 2>&1; then     # err msg suppressed
    $__pa_python --version || true      # Display the suppressed error message
    echo 1>&2 "pactivate: bad python interpreter: $__pa_python"
    __pa_cleanup; return 3
fi

#   $__pa_pyver is empty for "modern" versions of Python (i.e., those that
#   can use the current get-pip.py, 3.7 and above) and otherwise is the
#   major.minor revision number, suitable for use in the URL to download
#   an alternate version of get-pip.py.
__pa_pyver=$("$__pa_python" -c '
#   Reminder: this script must be compatible with Python 2 syntax.
import sys
M, m = sys.version_info[0], sys.version_info[1]     # Major, minor
if (M < 3 or (M == 3 and m < 7)):
    print("{}.{}".format(M, m))
')

__pa_requirements="$__pa_basedir/requirements.txt"

[[ -z $__pa_builddir ]] && __pa_builddir=$(cd "$__pa_basedir" && pwd -P)/.build

__pa_bootdir="$__pa_builddir/bootstrap/pactivate${__pa_pyver}"
mkdir -p "$__pa_bootdir"    # also ensures that $__pa_builddir exists

#   Unlike virtualenv, pip -t does not change the bin/ directory to
#   Scripts/ on Windows, so we can hardcode our bootstrap/bin/pip path.
[[ -x $__pa_bootdir/bin/pip ]] || {
    echo "----- Installing bootstrap pip (ver=${__pa_pyver:-latest})"
    #   get-pip.py produces spurious upgrade notices on older Python versions
    #   such as 3.6 or 2.7; --disable-pip-version-check suppresses these.
    curl ${__pa_quiet:+--silent} \
        "https://bootstrap.pypa.io/pip/$__pa_pyver/get-pip.py" \
        | "$__pa_python" - \
            $__pa_quiet -t "$__pa_bootdir" --disable-pip-version-check
    PYTHONPATH="$__pa_bootdir" "$__pa_bootdir/bin/pip" --version
}

[[ -d $__pa_bootdir/virtualenv/ ]] || {
    echo '----- Installing bootstrap virtualenv'
    #   This install produces spurious "bootstrap/.../bin already exists"
    #   messages; --upgrade suppresses these. However, we can't use it on
    #   Windows becuase there it, for mysterious reasons probably related
    #   to NTFS, generates an error trying to unlink bin/pip.exe.
    PYTHONPATH="$__pa_bootdir" "$__pa_bootdir/bin/pip" $__pa_quiet install \
        $([[ ${MSYSTEM-} ]] || echo --upgrade) -t "$__pa_bootdir" virtualenv
}

[[ -d $__pa_builddir/virtualenv/ ]] || {
    echo '----- Building virtualenv'
    echo -n "Using $__pa_python"
    if [[ -L $__pa_python ]]; then
        #   MacOS readlink has no -f option, so we must do this the hard
        #   way. Fortunately we already know that the binary exists and is
        #   a Python interpreter.
        __pa_python_deref=$(readlink "$__pa_python")
        __pa_python_deref=$(cd "$__pa_basedir" \
            && cd $(dirname "$__pa_python_deref") \
            && pwd -P)/$(basename "$__pa_python_deref")
        echo " -> $__pa_python_deref"
    else
        __pa_python_deref="$__pa_python"
        echo
    fi
    echo -n "Version: " && "$__pa_python" --version
    PYTHONPATH="$__pa_bootdir" "$__pa_python_deref" -s -m virtualenv \
        $__pa_quiet --prompt $(dirname "$__pa_basedir") \
        "$__pa_builddir/virtualenv/" \
    && [[ -f "$__pa_requirements" ]] \
    && "$__pa_builddir"/virtualenv/[bS]*/pip \
        install $__pa_quiet -r "$__pa_requirements"
}

cmp "$__pa_python" "$__pa_builddir"/virtualenv/[bS]*/python || (
    echo 1>&2 "WARNING:" \
        "${__pa_builddir#$__pa_basedir/}"/virtualenv/[bS]*/python \
        "($("$__pa_builddir"/virtualenv/[bS]*/python --version 2>&1))" \
        "is not $__pa_python" \
        "($("$__pa_python" --version 2>&1))" \
    )

. "$__pa_builddir"/virtualenv/[bS]*/activate
__pa_cleanup
